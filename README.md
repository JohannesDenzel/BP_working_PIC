# BP_working_PIC
Bachelorprojekt 2020:  Automatische Wildvogel Fütterung, PIC Code 

# 1.0 - Basics 
## non-return-to-zero (NRZ) format of the Serial Communication 
 
The NRZ format is very similar to the RS232 Standard but works in a different voltage range.  The serial sata using the NRZ format on the RX and TX pins of a microcontroller can be easily converted to USB using a Serial to USB converter in the correct input Voltage range. The NRZ format is automatically used by the PIC and doesn't need to be coded by software. 
 
Basically the NRZ format has two states VOH which represents a '1' data bit also called a mark and VOL which represents a '0' data bit also called space. NRZ refers to the fact that consecutively transmitted data bits of the same value stay at the output level of that bit without returning to a neutral level between each bit transmission.  An NRZ transmission port idles in the Mark state.  Each character transmission consists of one start bit followed by eight or nine data bits and is always terminated by one or more Stop bits.  The Start bit is always a Space and the stop bits are always Marks.  The most common data format is eight bits.  Each transmitted bit persists for a period of 1/(Baud Rate).  
 
On the PIC an on-chip dedicated 8-bit/16- bit Baud Rate Generator is used to derive standard baud rate frequencies from the system oscillator. 
 

## 1.1 - The 1-Wire Protocol  
 
This protocol is used for a lot of sensors produced by the company Dallas Semiconductor Corp. The 1-Wire bus system only needs two wires: GND and the bus wire.  The sensor can be also powered by the bus or by an extra power wire. There is always only one master and one or multiple slaves per bus system. The 1-Wire bus requires a pullup resistor of approx. 5 kOhm.  The Communication following the 1-Wire Protocol has to always follow the same command sequence: 1. Initialization:  Reset impuls performed by the master followed by a presence pulse performed by the slaves. 2. ROM command followed by any required data exchange. As example sending the Match ROM command on the bus followed by the 64 bit address of a sensor. 3. Function command, followed by any required data exchange. As example requesting the last measured temperature data by reading the scratchpad of a temperature sensor, followed by the sensor sending the data in the scratch. 
 
More Information can be found in the Datasheet of the DS18B20 Sensor on Page 10 – 18 and the tutorial by microchip Corp. on how to use 1-Wire using a PIC microcontroller. 
 
 
 
## 1.2 - Generating a PWM Signal on the PIC 
 
A Pulse-Width Modulation (PWM) is a method to provide power to a load by switching quickly between fully on and off states. This way the power provided to the load can be controlled.  

 
The power provided to the load is proportional to the duty cycle (D) of the PWM Signal.  The Term duty cycle describes the proportion of the on time to the off time and is expressed in %. A duty cycle of 0% means fully off and 100% fully on. 
 
A more detailed explanation about how PWM works can be found in chapter 3.3 of this report. 
 
To create a PWM signal on the PIC the chosen CCP Module and corresponding  output pin must be configured correctly. To create a PWM signal with the frequency f, a 8 bit timer x must be chosen. The timer also needs to be configured.  Additionally a value must be written into the PRx Register. The PWM Period T (f=1/T) is automatically generated by comparing the PRx value to the counter of the timer. The time the counter needs to reach the value in PRx  is the Period of the PWM Signal. The duty cycle can be set by writing a value into the CCPxL register. Please note that the Value written into the CCPxL register must be smaller than the Value written into the PRx Register! It's also possible to reach a resolution of 10 bit for the PWM Signal. 
 
A more detailed explanation on how PWM  works on the PIC can be found in the datasheet in the chapter 14.3 PWM Overview, page 180 – 183. 


# 2.0 - Code Overview 
Some rules of the protokoll are also used in the code. The thought behind it is, to make it simpler if things need to be changed later. For example sending a PWM duty cycle for heating via Serial. 
 Used Pins & Modules 
 The following tables are showing the Pins and Modules of the PIC used for this Project. 
  

## 2.1 - Pins  
 
Usage     |    Pin 
----------|--------
1-Wire Bus  |  RC5
Serial RX   |  RC7
Serial TX    | RC6
Heating PWM   |RB0
Cooling PWM   |RC2
Pump PWM      |RA4
 
## 2.2 - Modules 
 
Usage Module Notes Serial Communication EUSART  Time Window CCP2 Uses the Timer 1 as Clocksource Heating PWM CCP4 Uses the Timer 2 as Clocksource Cooling PWM CCP1 Uses the Timer 4 as Clocksource Pump PWM CCP5 Uses also the Timer 2 as Clocksource (same Frequency as Heating PWM) Timer for CCP2 Timer1/3/5  Timer for CCP1,4,5 Timer2/4/6  
 
 
The following table gives a quick Overview over the c- and h-files of this project and what they are used for. 
 
File name | Description 
----------|------------
global_Config.h | Header file used for configuration | 
PIC_PI_Prot.c | 'C' file containing all the functions regarding the communication protocol. It also contains the functions for reading values following the protocol, executing commands, setting the PWM output, and controlling temperatures  
PIC_PI_Prot.h | Header File for PIC_PI_Prot.c containing all the Function Prototypes and their Description and other header files that need to be included 
SerCom.c | C-File with all the functions regarding the serial basic communication 
SerCom.h | Header file for SerCom.c containing the function prototypes and other included headers  
CCP2_Timer.c | File containing the functions to create the time windows for the serial communication 
CCP2_Timer.h | Corresponding header file 
DS18B20.c | File containing all the functions used for  measuring the temperatures with the digital temperature sensors
DS18B20.h | Corresponding header file 
PWM.c | File Containing functions to setup the PWM output pins with the frequency values set in global_Config.h 
PWM.h | Corresponding header with Prototypes 
main.c | Main file containing the main function, there everything is put together to get an working solution 
 
 
# 3.0 - global_Config.h 
 Now the contents of the file global_Config.h will be explained in more detail. 
 
The file contains all the configuration macros to easily reconfigure things in the code. 
 
The following Tables are containing all the Makros in global_Config.h that can be changed if needed. The values next to the Makros are the values in the Code and could be changed if needed.  
 
## general 
 
| Makro & Value | Description/Explanation | 
--------------------------|------------------------
| \_XTAL\_FREQ 16000000 | The Frequency of the main clock configured in the _init_ function in the main.c file. If the Frequency is changed in the _init_() function the \_XTAL\_FREQ needs to be changed accordingly! Warning! by changing the frequency, everything that needs correct timing might need to be changed |
| SAFETY_ON 1 |  Turn the Safety Mode on (1) or off (0). If it's on, all the PWM duty cycles are set to zero if there is no response from the RPI in the given time. |

 
 
 

## Peltier Element Overheat Prevention 

| Makro & Value | Description/Explanation |
| --------------|-------------- |
| PT\_MIN\_PWM_DC  5 | minimum PWM duty Cycle in %, it's just enough to prevent the heat from the hot side to move to the cold side. At this value the Peltier element can’t
overheat| 
| PT\_OH\_T 40  | Peltier element Overheat temperature: if the hot side of the peltier element reaches this temperature the PWM Duty cycle will be set to PT\_MIN\_PWM\_DC | 
| PT\_OFF\_T    | 70 Peltier element off temperature: at this temperature the Peltier Element will be turned off to prevent damaging it. if its turned off the heat will travel from the hot side to the cool side causing the container to heat up fast. | 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Bytes used in the Serial Communication Protocol 
 
There is a "Production" byte set and a "Debugging" byte set. The debugging Byte set can be used for debugging purposes if a Serial Monitor like the one from the Arduino IDE is used.  The Bytes in the Debugging set correspond to chars in the ASCII Table that can be read in the Serial Monitor. The Production Set is used in the normal working Mode. 
 
More details about the protokoll can be found in chapter 5.2  
 

 
 
56 
 
Macro Debugging decimal, char 
Production decimal 
Description/Explanation 
ACK 97,   a 101 Acknowledged can be sent by both RPI and PIC NACK 110, n 102 Not acknowledged can be sent by both RPI and PIC CPS 112, p 103 Change pump speed sent by RPI CHT  104, h 104 Change heating temperature sent by RPI CCT 99,   c 105 Change cooling temperature sent by RPI CSS 115, s 106 Change system state sent by RPI IWT 105, i 201 I wanna talk sent by PIC IDWT 100, d 202 I don't wanna talk sent by PIC IWR 114, r 203 I wanna read  sent by RPI FRAERR 70,  F 0 Framing Error sent by PIC OVERERR 79,  O 0 Overrun Error sent by PIC 
 
 
 
 
 
 
 
 
 
 
 

 
 
57 
PWM  
 
The following table shows the macros for changing the PWM configurations 
 
Macro name Value Description/Explantation DUTY_CYC_C_MAX 30 Maximum Duty Cycle Value for Cooling PWM. This Value is NOT the percentage, its the maximum Value to be written into the CCPxL Register. So it has to be smaller than the PR_C Value. PR_P  199 Set Pump Frequency, at current settings 5 kHz PR_H  PR_P Set Heating Freq. Needs to be the same as Pump Freq. Because both use the same Timer PR_C 40 Set Cooling Frequency, currently set to 97,5 kHz 
 
 
Digital Temperature Sensor DS18B20  
 
The code should work for all sensors using the 1-Wire Protokoll. If needed the port (pin) and the commands can be easily changed. Currently the Port RC5 is used. 
 
 
Pin Configuration Makro name Value LAT_DQ LATCbits.LC5 DQ PORTCbits.RC5 TRIS_DQ TRISCbits.TRISC5 
 
 
 
 
 
 
 

 
 
58 
Commands 
 
These Commands are Specific for the DS18x20 Sensors See Datasheet of the Sensor for detailed explanation on the Commands. 
 
Macro name Value Description Skip_ROM 0xCC address all Sensors on the Bus Read_ROM 0x33 Read ROM Address. Use only if one Sensor is on the Bus! Match_ROM 0x55 address one Sensor with the Address sent after this command Alarm_Search 0xEC Search for temperature alarm on the Bus Convert_T 0x44 Start Temperature Measurement. Temperature can be read after a minimum 750 ms. Read_scratch 0xBE Read Scratchpad. It contains the last Measured Temperature and a few other Bytes.  Write_scratchpad 0x4E Write Bytes to the Scratchpad Copy_scratchpad 0x48 Copies byte 2,3,4 of the Scratchpad to the EEPROM of the Sensor. Can be used to change configuration of the Sensor Resolution_11bit 0x5F Change the Resolution of the temperature measurement to 11 bit Resolution_12bit 0x7F Change the Resolution of the temperature measurement to 12 bit 
 
 
4.4.4 - Library Functions 
 4.4.4.1 - Overview  
 The following table contains a short Overview which file contains which functions. 
 
The functions are arranged in the order corresponding to the file Overview Table. 
 

 
 
59 
C-file and associated header Function name PIC_PI_Prot.c PIC_PI_Prot.h readValue executeCommand SerStartEnd SetPumpSpeed SetHeatingPWM SetCoolingPWM HeatingTempControl CoolingTempControl SerCom.c SerCom.h SetupSerial SerialSend SerialRec CCP2_Timer.c CCP2_Timer.h CCP2_TimerSetup CCP2_SetTimer CCP2_Reset DS18B20.c DS18B20.h ow_mri ow_rd_bit ow_rd_byte ow_wr_bit ow_wr_byte ConvTempInt SelectSensor ReadTemperature PWM.c PWM.h Setup_Pump_PWM Setup_Heating_PWM Setup_Cooling_PWM 
 
 
 
 
 
 
 
 

 
 
60 
 
4.4.4.2 Functions Explained 
 Every Function is explained with the following structure: 
 
Files (containing the header and the functions): 
 
Function Prototype 
 
Inputs –  Explanation 
 
Outputs –  Explanation  
 
Description 
 
Notes: 
 
For a better clarity the actual code of the functions is explained using the comments in the code. 
 
 
 
4.4.4.2.1 Communication Protocol 
 Files: PIC_PI_Prot.h PIC_PI_Prot.c 
 
uint8_t  readValue(uint16_t) 
 
Inputs:  uint16_t  timeWindow_par  Time window for reading a Value from the Serial Bus 
 
Output: Byte that was read from the Serial Bus (actually not really a bus). 
 
The function readValue reads a value from the Serial bus using the function SerialRec. It waits for  timeWindow_par milliseconds for a value of the type uint8_t between 1 and 100. If a value is received the function 

 
 
61 returns this value and is left immediately. If no value between 1 and 100 is received in the time window the function will return the byte NACK from the Serial communication Protocol.  
 
void  executeCommand(uint8_t, uint8_t) 
 
Inputs:  uint8_t command Command byte received via Serial uint8_t value Received value 
 
Outputs: none 
 
Description: The function executeCommand can receive the command bytes CPS, CSS, CHT and CCT of the serial communication protokol and a value needed for the command.  After it receives the command byte, it will execute the corresponding command. As example: If the input is: CPS, 30 The function SetPumpSpeed will be called with the value 30 and with that the duty cycle of the PWM Signal controlling the pump will be set to 30%. 
 
 
uint8_t  SerStartEnd(uint8_t, uint16_t) 
 
Inputs: uint8_t data_par Byte that should be sent. IWT or IDWT uint16_t timeWindow_par Time window for receiving an answer 
 
 
Outputs: Serial response 
 
The function  SerStartEnd is used at the beginning and end of the time window for serial communication. It sends the byte in data_par via serial and expects a response not equal to NACK.  If there is no response after timeWindow_par milliseconds it will try again two more times. If there is 

 
 
62 
still no response after 3 tries the function will return NACK. If there is a response it will return the response byte and exit the function. 
 
Note: This function uses the functions SerialSend and SerialRec that can be found in the file SerCom.c If SerialRec receives nothing (0) it will return NACK.  
 
 
uint8_t  SetPumpSpeed(uint8_t) 
 
Inputs: uint8_t value_par Duty cycle in % for the PWM controlling the pump 
 
 
Output: ACK or NACK 
 
The function sets the duty cycle of the PWM Signal controlling the pump to the value given as input. If the input value is bigger than 100 the function will return NACK, else it returns ACK. If the input value is smaller than 20% the pump will be turned off because with less than 20% the Pump will not run. 
 
 
uint8_t  SetHeatingPWM(uint8_t value_par) 
 
Inputs: uint8_t value_par Duty cycle in % for the PWM controlling the Heating Element 
 
 
Outputs: ACK or NACK 
 
The function SetHeatingPWM works similar to the function SetPumpSpeed. The only difference is that the Heating Element will be turned off if the input value is smaller than 6. 

 
 
63 
 
 
uint8_t  SetCoolingPWM(uint8_t value_par) 
 
Inputs: uint8_t value_par Duty cycle in % for the PWM controlling the Peltier Element 
 
 
Outputs: ACK or NACK 
 
The function SetCoolingPWM works similar to the function SetPumpSpeed. The only difference is that the Peltier Element will be turned off if the input value is smaller than 2. 
 
 
 
uint8_t  LinearTempControl(int8_t Ts, int8_t Tm, uint8_t dTmax) 
 
not used anymore in the code 
 
Inputs: 
 
Outputs: 
 
 
uint8_t  HeatingTempControl(uint8_t Ts, int8_t Tm, uint8_t dTmax) 
 
Inputs: uint8_t Ts Set temperature int8_t Tm Measured temperature uint8_t dTmax Maximum temperature difference 
 
 
Outputs: Duty cycle in % meant for the PWM signal controlling the heating element 
 

 
 
64 
The function HeatingTempControl calculates the PWM duty cycle in % for the heating element depending on the temperature difference between a measured temperature and a set temperature.  If the measured temperature is bigger than the set temperature the duty cycle will be 1% (minimum possible value in the protokoll). 
 
Note: In this case following the protocol would not be necessary because the duty cycle is neither sent or received via serial, so the value could also be 0%.  But still following the protocol makes it easier if things need to be changed later. For example sending the PWM Value for heating via Serial following the protokoll. 
 
 
uint8_t  CoolingTempControl(int8_t Ts, int8_t Tm, uint8_t dTmax) 
 
 
Inputs int8_t Ts Set temperature int8_t Tm Measured temperature uint8_t dTmax Maximum temperature difference 
 
Output: Duty cycle in % meant for the PWM Signal controlling the Peltier Element 
 
The function CoolingTempControl works similar to HeatingTempControl the difference is that the measured temperature needs to be bigger than the set Temperature to turn on the cooling. Also both temperatures can be negative and instead of 100% as full power it uses DUTY_CYC_C_MAX as full power if the measured temperature difference is bigger than dTmax. That is to prevent the peltier element from overheating too fast. 
 
 
 
 
 

 
 
65 
4.4.4.2.2 Serial Communication 
 Files: SerCom.c SerCom.h 
 
void SetupSerial(void) 
 
Inputs: none 
 
Output: none 
 
Initializes the Serial Communication by configuring the EUSART module of the PIC and configures the RX and TX Pins. The Baud Rate is 9600 baud with an error of 0.08% at clock frequency of 16MHz. If the clock frequency is changed the Baudgenerator must be reconfigured (for Configuration see the Datasheet page 272 – 275, especially the tables for some configurations of the baud generator on page 273 - 275).  
 
 
 
 
void SerialSend(uint8_t data_par) 
 
Inputs uint8_t data_par Data byte that should be sent 
 
Output: none 
 
Sends one byte via Serial. 
 
uint8_t SerialRec(void) 
 
Inputs: none 
 
Output received Databyte 
 
If nothing is received the function will return NACK. The Possible Errors are Framing error (FRAERR) and Overrun 

 
 
66 
(OVERERR) error.  Framing error indicates that a stop bit was not seen at the expected time.  Overrun error means that the PIC received more bytes than the buffer can hold. The buffer is emptied by reading it. If an error occurred the PIC will send the corresponding error byte specified in global_Config.h and restart the EUSART Module or the receiver circuit. That takes around 1 ms. In this case the function will return NACK. Without this error handling the PIC couldn't receive any data after the error occurred. If everything works fine the function returns the received Databyte. 
 
 
4.4.4.2.3 Time Window 
 Files: CCP2_Timer.c CCP2_Timer.h 
 
void CCP2_TimerSetup(void) 
 
Inputs: none 
 
Output: none 
 
The function CCP2_TimerSetup configures the CCP2 module and Timer 1 to be able to measure the time with 1 us accuracy (at 16 Mhz clock freq.) to create the time windows used for the serial communication.  
 
void CCP2_SetTimer(uint16_t) 
 
Inputs uint16_t timeSet_par Set timer with desired time in microseconds 
 
Output: none 
 
The function sets a timer with the input in microseconds and resets the flag of timer 1 and the CCP2 module. If the Timer reaches the set microseconds, the flag PIR2bits.CCP2IF is set. The flag has to be 

 
 
67 
cleared after reading it! 
 
void CCP2_Reset(void) 
 
Inputs: none 
 
Output: none 
 
Resets the counter of timer 1 and resets the flags of the CCP2 module and Timer 1. 
 
 
4.4.4.2.4 One-Wire communication protocol for the DS18B20  
 Part of these functions were copied from  ​https://pic-projekte.de​ but needed to be changed because the timing for the 1-Wire protocol wasn't right. To correct it the code of the Arduino Library OneWire by Paul Stoffregen was used and rewritten so that it works on the PIC. The "ow_..." functions are a combination of the provided functions and the rewritten functions from the arduino code. "ow" is an abbreviation for 1-Wire The other functions were added to the files. 
 
Files: DS18B20.c DS18B20.h 
 
 
uint8_t ow_mri (void) 
 
Inputs: none 
 
Output 0 if slave available  1 if no slave on the bus 
 
the functions  ow_mri performs the 1-Wire Master Reset Impuls, to check if there are any slaves available on the bus. If there is a slave on the bus it will pull the bus to low for a fixed amount of time. If the function detects a slave it will return 0 if not 1. 
 

 
 
68 
uint8_t ow_rd_bit (void) 
 
Inputs: none 
 
Output:  1 or 0  
 
This function reads one bit from the bus following the 1-Wire protokoll and returns it. 
 
uint8_t ow_rd_byte (void) 
 
Inputs: none 
 
Output: one byte read from the bus 
 
The function  ow_rd_byte reads one byte from the bus using the function ow_rd_bit. 
 
void ow_wr_bit (uint8_t val) 
 
Inputs uint8_t val Bit to be written to the 1-Wire bus 
 
Output: none 
 
This function writes one bit to the bus, following the 1-Wire protocol. 
 
void ow_wr_byte (uint8_t val) 
 
Inputs:  uint8_t val Byte to be written on the 1-Wire bus 
 
Output: none 
 
This function writes a complete byte to the bus. 
 
int8_t ConvTempInt(uint8_t [9]) 
 

 
 
69 
Inputs uint8_t sensorData_par[ ] Data read from the scratchpad of a Sensor 
 
Output: Temperature: -127°C to +127°C 
 
This function takes the scratchpad read from a DS18B20 sensor as input and uses it to calculate the measured temperature.  If no sensor is connected or they have no power (pullup resistor missing?), this function will return 0. In this application only one sensor could actually happen to measure 0°C. If at least 1 sensor is connected, but it is tried to calculate the temperature of a disconnected sensor the function will return -127. This could be used to detect connection problems.  
 
void SelectSensor(uint8_t [8]) 
 
Inputs: uint8_t sensorAdress_par[8] 64 bit sensor address 
 
Output: none 
 
This function selects one Sensor with its 64 bit address given as input.  Directly after calling this function a command has to be sent to the selected sensor. 
 
 
 
int8_t ReadTemperature(void) 
 
Inputs: none 
 
Output Temperature between -127°C and +127°C 
 
This function can be called directly after SelectSensor. It will send the command to read the Scratchpad and then convert the received data to a temperature between -127°C and + 127°C using the ConvTempInt function. 
 

 
 
70 
4.4.4.2.5 PWM 
 Files PWM.c PWM.h 
 
void Setup_Pump_PWM(void) 
 
Inputs: none 
 
Output: none 
 
This function configures the CCP5 Module to output PWM on the pin RA4, with the frequency set by the value of PR_P, defined in global_Config.h using the Timer 2. 
 
void Setup_Heating_PWM(void) 
 
Inputs: none 
 
Output: none 
 
Configures the CCP4 Module to output PWM on the pin RB0, with the frequency set by the value of PR_H defined in global_Config.h using the timer 2. Heating and pump use the same timer that means PR_H and PR_P need to have the same value, if not the value configured last will be used. 
 
void Setup_Cooling_PWM(void) 
 
Inputs: none 
 
Output: none 
 
take a guess 
 
This function configures the CCP1 Module to output PWM on the pin RC2, with frequency set by the value of PR_C defined in global_Config.h using the timer 4. 
 

 
 
71 
 
4.5 The Main Function 
 
 
The function starts with initializing pwmval_h,   pwmval_c that are needed for the automatic temperature control. Also the variable for receiving a byte via serial is initialized here. 
 
       uint8_t​ pwmval_h = ​1​; ​//value between 1 and 100 for heating     ​uint8_t​ pwmval_c = ​1​; ​//value between 1 and 100 for cooling        ​uint8_t​ serRec = NACK;    Start of the while loop that will never be exited.  Everytime the code in the loop is executed again the first LED will be toggled, that is to indicate visually if the code is still running.      while​(​42​){   LATBbits.LB2 ^= ​1​; ​//LED 1 toggle every loop to see if PIC is running    
 The EUSART Module needs to be disabeled if it can’t be used, because receiving too many bytes while they are not read from the buffer register causes an Overrun error. 
      ​SER_EN = ​0​; ​//disable Serial, to prevent overrun error because bytes cant //be processed   After disabling EUSART the command sequence for starting the Temperature measurement with the Sensor using the 1-Wire Protocol is started. After sending the command Convert_T the PIC needs to wait or do something else for at least 750 ms, until the temperature can be read.      ​//Sensor send Measurement commands         ​uint8_t​ mri = ow_mri(); //1. Master Reset Impuls  

 
 
72 
        ​if​(mri == ​0​){ //Slave available             ow_wr_byte(Skip_ROM); //speak to all Sensors             ow_wr_byte(Convert_T); //Start Temperature Conversion          }         ​//do sth else for at least 750ms   To start the Serial communication with the RPI the EUSART Module will be enabled again. To make sure it has enough time to start running the PIC will wait 1ms before and after enabling the module.             __delay_ms(​1​);          SER_EN = ​1​; ​//enable Serial         __delay_ms(​1​); ​//delay to make sure the enabling is finished   
 To tell the RPI that the PIC is now available for Serial Communication via the RX and TX wires, the PIC sends the byte IWT that means "I want to talk" as explained in the protokol. Inside the function SerSartEnd IWT can be sent 3 times and each time the PIC waits for 50000 microseconds until the RPI responds. As explained above in chapter 4.4.4.2.1 If there is no response from the PIC and the Safety Mode is on (see global_Config.h, ch. 4.4.3), the pump, heating and peltier element will be turned off. And the byte NACK will be sent to the RPI to indicate that there was a problem with the communication.      //Start Serial Communication by sending IWT         ​uint8_t​ iwt_resp = SerStartEnd(IWT, ​50000​);         ​if​(iwt_resp == NACK){   ​//no response   #if SAFETY_ON == 1 
             DUTY_CYC_H = ​0​;     ​//turn off heating             DUTY_CYC_P = ​0​;     ​//turn off pump             DUTY_CYC_C = ​0​;    ​//turn off cooling   

 
 
73 
#endif               SerialSend(NACK);   ​//send nack  
 
If the RPI already answered to IWT with a command or the ACK byte got lost, and the command was the first detected response, the command will be moved to the variable serRec for later use.      //RPI might have sent the Command already          }​else​ ​if​(iwt_resp != NACK && iwt_resp != ACK){  
             serRec = iwt_resp;  ​//save iwt_Resp in serRec             iwt_resp = ACK;     ​//set iwt_Resp to ACK         } 
 
  The following lines are starting the time window for the serial communication. In this case the time window is approx. 1000 ms. It needs to have at least 750 ms! The big time window is created by repeating a time window of 10 ms 100 times using the for loop. The actual 10 ms time window starts with "while(!(CCP2_F)){ ". The flag CCP_F will be set every 10 ms and it is reset to 0 inside of the CCP2_SetTimer function.     for​(​int​ i = ​0​; i < ​100​; i++){ ​//Time Window*settimer        CCP2_SetTimer(​10000​); ​//reset flags and set 10ms      ​while​(!(CCP2_F)){ ​//10ms time window 
 
 
The following lines are initializing the variable for the value that should be received after receiving one of the change commands and checking if the last byte received was one of the following CPS = change pump speed, CSS = change system state, CHT = change heating temperature, CCT = change cooling temperature. If that is true the PIC will wait for a maximum of 20 ms for a value sent 

 
 
74 
via Serial using the function readValue explained in chapter 4.4.4.2.1 The variable serRec containing the received byte is updated at the end of the while loop to make sure that a command received as answer for IWT can also be processed. 
 
  uint8_t​ value = ​0​; ​//init received data value if​(serRec == CPS || serRec == CSS || serRec == CHT || serRec == CCT){    ​//value that follows a change command, input: timewindow    value = readValue(​20000​);       ​if​(value == NACK){ ​//if no value read in Time Window it returns NACK        SerialSend(NACK);        ​continue​;        } 
 
After receiving the value, it is checked if it's in the correct range (1-100). If that's the case the command will be executed with the given value using the  executeCommand function after the execution the PIC sends back ACK via serial. 
 
        ​if​(​1​ <= value && value <= ​100​){ ​//if value in range 1-100          executeCommand(serRec, value); ​//only executes valid commands         SerialSend(ACK);         ​// LATBbits.LB3 ^= 1; //toggle LED 2, for debugging         }​else​{           SerialSend(NACK); ​//no value or bigger than 100         }   If the received command byte is not a change command but the command IWR (“i want to read”), the PIC will respond by sending back the last measured temperatures. So if the other device (RPI or ESP32) starts very fast, after turning everything on (less than 150ms), the first temperatures sent could be wrong.  The temperatures sent can be in the range -19°C to +80°C. The actual value sent is the measured temperature +20. This way temperatures below 1 that wouldn't be in the protocol can also be sent using only one 

 
 
75 byte. No temperature measured for this project should be outside of this range. If a temperature outside this range is measured the value 100 will be sent.  After sending the temperatures and leaving the if branch the variable serRec will be updated with the next byte from the receiving buffer.   } ​else​ ​if​ (serRec == IWR){     ​//I wanna Read: Send all system data                     ​// Send all temperatures                      ​// current Pumpspeed, set heating, cooling                      temperature might also be needed                     ​// Suggestion:                     ​// IWRMT     i wanna read all measured Temperatures                     ​// IWRSHT    i wanna read set heating Temperature                     ​// IWRSCT    read set cooling temperature                     ​// IWRP      read set Pump speed                       ​//Temperature Range numbers: 1 - 100                     ​//valid measured range -19 to + 79°C                     ​//sent 20 means 0°C sent 44 means 24        ​if​(​-19​ <= T1 && T1 < ​80​){     SerialSend(T1 + ​20​);  ​//can send value between 1 and 99   }​else​{    SerialSend(​100​); ​//nothing should be 80°C hot -> send 100 = to Hot,                     //error     }     ​if​(​-19​ <= T2 && T2 < ​80​){    SerialSend(T2 + ​20​);    }​else​{    SerialSend(​100​); ​//nothing should be 80°C hot -> error   }     ​if​(​-19​ <= T3 && T3 < ​80​){ 

 
 
76 
   SerialSend(T3 + ​20​);    }​else​{    SerialSend(​100​); ​//nothing should be 80°C hot -> error   }  }   serRec = SerialRec(); ​//update Serial Receive   } ​//10ms time window inside for 750ms   } ​//for 750ms 
 
At the end of the time window for the serial communication the PIC will send the byte IDWT ("I don't want to talk") via serial in the same way as the IWT at the beginning of the serial communication  time window, also with 3 tries with 50 ms time out. If the RPI (or the other side of the bus) does not respond there won't be a safety turn off, because one turnoff at the beginning is enough. 
 
  uint8_t​ idwt_resp = SerStartEnd(IDWT, ​50000​);   //no safety turnoff because its enough at the beginning of communication  
 
 
After the sending of the IDWT byte, the EUSART module will be disabled to prevent a potential overrun error. Similar  to enabling the module there is a delay of 1 ms after disabling it.    SER_EN = ​0​; ​//Disable serial         __delay_ms(​1​); 
 
After disabling EUSART the temperatures are read from the sensors by performing the communication sequence of the 1-Wire protocol explained in chapter 4.4.1 - Basics  for reading each sensor.  The used functions can be found in the file DS18B20.c.      

 
 
77 
//read temperature from Sensors mri = ow_mri(); if​(mri == ​0​){   SelectSensor(adrSensor1);   T1 = ReadTemperature(); } mri = ow_mri(); if​(mri == ​0​){   SelectSensor(adrSensor2);   T2 = ReadTemperature(); } mri = ow_mri(); if​(mri == ​0​){   SelectSensor(adrSensor3);   T3 = ReadTemperature(); }     After reading the temperatures from the sensors the temperature controlling of the heating and Peltier Element starts. The temperature of the heating element  and peltier element is controlled depending on the difference between the set and measured Temperature using the functions  HeatingTempControl and  CoolingTempControl that are explained in chapter 4.4.4.2.1.  These functions are returning the duty cycle in % between 1% and 100%.  The temperatures are set by sending CHT or CCT  followed by the desired temperature +20. The actual PWM Signal is set using  SetHeatingPWM and SetCoolingPWM. For the Peltier Element the temperature of the hot side must also be checked to turn the Peltier (PT) element off if it gets too hot, to prevent damage because of overheating. If the temperatures for the hot and cool side of the PT element are in a valid range and the temperature of the hot side is bigger than  PT_OH_T set in global_Config.h the pwm value of the PT element will be set to a minimum value  PT_MIN_PWM_DC also defined in global_Config.h. The same goes for the maximum overheat Temperature  PT_OFF_T, if this is reached the Peltier element will be completely turned off.  The setting of the actual PWM signal for the PWM element happens after 

 
 
78 
the Overheat control. The temperatures are first checked if they are in a valid range, because it might be possible that the values received from the sensors are corrupted, thus the measured temperatures seem wrong. To prevent the PT element from being needlessly turned off because of this, the range is first checked. 
 
The functions can be found in the file: PIC_PI_Prot.c     
 
/****************************************************************** ****/ //Temperature Control each Time a new temperature is (or should be) measured 
 
/****************************************************************** ****/ //Calculate Duty Cycle Percentage   int8_t​ measHeatingTemp = T3; ​//2 rings  int8_t​ measPtCoolTemp  = T2; ​//1 rings int8_t​ measPtHotTemp   = T1; ​//0 rings     //heating if​(​-30​ < T3 && T3 < ​120​){   pwmval_h = HeatingTempControl(set_ht_global, T3, ​10​);   } ​//else use old value       //Convert Percentage to Duty cycle value and set duty cycle uint8_t​ h_res = SetHeatingPWM(pwmval_h); ​//heating result ACK or NACK     /*Overheat control of peltier element*/ //measPtCoolTemp = -10; //for testing purposes 

 
 
79 
if​((​-20​ < measPtCoolTemp && measPtCoolTemp < ​100​) && (​-20​ < measPtHotTemp && measPtHotTemp < ​100​) ){ ​//check if Temperatures are in valid range    ​if​(measPtHotTemp >= PT_OFF_T){ ​//turn off Temperature    pwmval_c = ​1​;  ​//1% duty cycle (minimum value in protokoll)    }​else​ ​if​(measPtHotTemp >= PT_OH_T){   pwmval_c = PT_MIN_PWM_DC; ​//minimum duty cycle of Pt element so that                             // the cool side stays cool but the hot side                             // doesn’t heat up more     }​else​{ ​//measHotTemp < overHeat     pwmval_c = CoolingTempControl(set_ct_global, measPtCoolTemp, 10​);     } }​else​{   pwmval_c = PT_MIN_PWM_DC;  } uint8_t​ c_res = SetCoolingPWM(pwmval_c);   } ​//while 42     return​; } ​//end of main 
 
 
4.6 - Testing / Debugging 
 The PWM Output on the pins of the PIC can be measured with an Oscilloscope but for simple testing a Multimeter is enough. It can be used to measure the DC voltage on the pins. The measured voltage is not exactly linear to the PWM duty cycle but for a lower duty cycle the measured voltage is lower and for a higher duty cycle the voltage is higher. 
 

 
 
80 
The Communication Protokoll can also be tested with an ESP32 Microcontroller instead of an RPI. The ESP and the PIC both run on 3.3V so there are no Level shifters needed. 
 
Using the ESP32 might be easier to use for beginners who never used a RPI.  
 
The ESP used for testing the PIC was coded in Arduino. The code can be found in the same file as this report. To connect the ESP32 to the PIC connect the pins as shown in the table. PIC ESP32  RX TXD2 (GPIO 17) TX RXD2 (GPIO 16) GND GND 
 
The protokol can be both used in debugging and production mode. 
 
The following table contains the bytes of the protokol mentioned in this chapter. byte number IWT 201 IDWT 202 IWR 203 ACK 101 
 
 
To test the code with the ESP32 first install the Arduino IDE, the ESP32 board also needs to be added so that it can be coded using Arduino. Then connect an ESP32 board to the PC and upload the code to the ESP. 
 
To test the protokol the ESP32 sends IWR after it receives an IWT or IDWT and sent back ACK. So make sure that the sensors are connected correctly or else the temperatures will be 0 or -20°C. The whole communication process can be seen on the serial monitor of 

 
 
81 
the Arduino IDE.  The values received are the measured temperatures +20. This way also negative temperatures down to -19°C can be sent. The maximum possible temperature that can be received is +80°C, that would be the value 100. The value 100 could also mean a temperature out of the range -19°C to 80°C. The values displayed in the Serial monitor means: 1. who sent it, PIC or ESP and if it’s sent by the ESP also the abbreviation ACK or IWR. 2. received or sent value as number. 3. received or sent number as character of the ASCII table. 
 
The user can type 'p' into the Serial monitor to pause the monitor and 's' to restart it. 
 
The result might look like this: 
 
PIC: 201  ESP ACK: 101 ESP IWR: 203 PIC: 43 + PIC: 44 , PIC: 44 , PIC: 202  ESP ACK: 101 ESP IWR: 203 PIC: 249  PIC: 201  
 
As seen above, without an Pulldown Resistor on the wires the ESP32 receives random numbers after the PIC disables the Serial Communication. As seen below, with an Pulldown Resistor on the wires the ESP32 always receives 0 after the PIC disables the Serial Communication. And 0 is not in the communication protocol. 
 
PIC: 201  ESP ACK: 101 ESP IWR: 203 PIC: 43 + 

 
 
82 
PIC: 44 , PIC: 44 , PIC: 202  ESP ACK: 101 ESP IWR: 203 PIC: 0  PIC: 201  
 
